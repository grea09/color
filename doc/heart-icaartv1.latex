\PassOptionsToPackage{unicode=true}{hyperref} % options for packages loaded elsewhere
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames*,x11names*}{xcolor}
%
\documentclass[a4paper,twoside, 10pt,twocolumn,]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
 %%%%% PANCAKE
	\usepackage{amsthm}
	\usepackage{mfirstuc}
	\theoremstyle{plain}
		\newtheorem{theorem}{\capitalisewords{theorem}}[]
			\newtheorem*{lemma}{\capitalisewords{lemma}}
		\newtheorem*{proposition}{\capitalisewords{proposition}}
		\newtheorem*{corollary}{\capitalisewords{corollary}}
		\theoremstyle{definition}
		\newtheorem{definition}{\capitalisewords{definition}}[]
		\newtheorem{conjecture}{\capitalisewords{conjecture}}[]
		\newtheorem{example}{\capitalisewords{example}}[]
		\newtheorem{postulate}{\capitalisewords{postulate}}[]
		\newtheorem{problem}{\capitalisewords{problem}}[]
			\newtheorem*{axiom}{\capitalisewords{axiom}}
		\theoremstyle{remark}
		\newtheorem{case}{\capitalisewords{case}}[]
			\newtheorem*{remark}{\capitalisewords{remark}}
		\newtheorem*{note}{\capitalisewords{note}}
	
 %%%%% PANCAKE
\makeatletter
\renewenvironment{proof}[1][\proofname]{\par
%  \pushQED{\qed}% <--- remove the QED business
  \normalfont \topsep6\p@\@plus6\p@\relax
  \trivlist
  \item[\hskip\labelsep
        \itshape
    #1\@addpunct{.}]\ignorespaces
}{%
%  \popQED% <--- remove the QED business
  \endtrivlist\@endpefalse
}
\renewcommand\qedhere{} % to ensure code portability
\makeatother
 %%%%% PANCAKE
 %%%%% PANCAKE
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

%%%%%% for algorithms
\errorcontextlines\maxdimen
\makeatletter
\algrenewcommand\ALG@beginalgorithmic{\footnotesize}
\algrenewcommand\alglinenumber[1]{\color{solarized-base0} #1}
\renewcommand{\algorithmiccomment}[1]{{\hfill\(\smalltriangleright\) \emph{#1}}}

\newcommand{\algorithmicbreak}{\textbf{break}}
\newcommand{\Break}{\State \algorithmicbreak}

% begin vertical rule patch for algorithmicx (http://tex.stackexchange.com/questions/144840/vertical-loop-block-lines-in-algorithmicx-with-noend-option)
% start with some helper code
% This is the vertical rule that is inserted
    \newcommand*{\algrule}[1][\algorithmicindent]{\makebox[#1][l]{\color{solarized-base0}\hspace*{.5em}\thealgruleextra\vrule height \thealgruleheight depth \thealgruledepth}}%
% its height and depth need to be adjustable
\newcommand*{\thealgruleextra}{}
\newcommand*{\thealgruleheight}{.95\baselineskip}
\newcommand*{\thealgruledepth}{.25\baselineskip}

\newcount\ALG@printindent@tempcnta
\def\ALG@printindent{%
    \ifnum \theALG@nested>0% is there anything to print
        \ifx\ALG@text\ALG@x@notext% is this an end group without any text?
            % do nothing
        \else
            \unskip
            \addvspace{-1pt}% FUDGE to make the rules line up
            % draw a rule for each indent level
            \ALG@printindent@tempcnta=1
            \loop
                \algrule[\csname ALG@ind@\the\ALG@printindent@tempcnta\endcsname]%
                \advance \ALG@printindent@tempcnta 1
            \ifnum \ALG@printindent@tempcnta<\numexpr\theALG@nested+1\relax% can't do <=, so add one to RHS and use < instead
            \repeat
        \fi
    \fi
    }%
\usepackage{etoolbox}
% the following line injects our new indent handling code in place of the default spacing
\patchcmd{\ALG@doentity}{\noindent\hskip\ALG@tlm}{\ALG@printindent}{}{\errmessage{failed to patch}}
\makeatother

%For nested Calls
\MakeRobust{\Call}

% the required height and depth are set by measuring the content to be shown
% this means that the content is processed twice
\newbox\statebox
\newcommand{\myState}[1]{%
    \setbox\statebox=\vbox{#1}%
    \edef\thealgruleheight{\dimexpr \the\ht\statebox+1pt\relax}%
    \edef\thealgruledepth{\dimexpr \the\dp\statebox+1pt\relax}%
    \ifdim\thealgruleheight<.75\baselineskip
        \def\thealgruleheight{\dimexpr .75\baselineskip+1pt\relax}%
    \fi
    \ifdim\thealgruledepth<.25\baselineskip
        \def\thealgruledepth{\dimexpr .25\baselineskip+1pt\relax}%
    \fi
    %\showboxdepth=100
    %\showboxbreadth=100
    %\showbox\statebox
    \State #1%
    %\State \usebox\statebox
    %\State \unvbox\statebox
    %reset in case the next command is not wrapped in \myState
    \def\thealgruleheight{\dimexpr .75\baselineskip+1pt\relax}%
    \def\thealgruledepth{\dimexpr .25\baselineskip+1pt\relax}%
}
% end vertical rule patch for algorithmicx
 %%%%% PANCAKE
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provides euro and other symbols
\else % if luatex or xelatex
  \usepackage{unicode-math}
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
    \setmainfont[]{Nimbus Roman No9 L}
  \setmathfont[]{STIX Two Math}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\usepackage{fancyvrb}
\usepackage{xcolor}
 %%%%% PANCAKE

\IfFileExists{xcolor-solarized.sty}{\usepackage{xcolor-solarized}} {
% We now define the sixteen \solarized{} colors.
\definecolor{solarized-base03} {RGB}{000, 043, 054}
\definecolor{solarized-base02} {RGB}{007, 054, 066}
\definecolor{solarized-base01} {RGB}{088, 110, 117}
\definecolor{solarized-base00} {RGB}{101, 123, 131}
\definecolor{solarized-base0}  {RGB}{131, 148, 150}
\definecolor{solarized-base1}  {RGB}{147, 161, 161}
\definecolor{solarized-base2}  {RGB}{238, 232, 213}
\definecolor{solarized-base3}  {RGB}{253, 246, 227}
\definecolor{solarized-yellow} {RGB}{181, 137, 000}
\definecolor{solarized-orange} {RGB}{203, 075, 022}
\definecolor{solarized-red}    {RGB}{220, 050, 047}
\definecolor{solarized-magenta}{RGB}{211, 054, 130}
\definecolor{solarized-violet} {RGB}{108, 113, 196}
\definecolor{solarized-blue}   {RGB}{038, 139, 210}
\definecolor{solarized-cyan}   {RGB}{042, 161, 152}
\definecolor{solarized-green}  {RGB}{133, 153, 000}
}
 %%%%% PANCAKE
\usepackage{hyperref}
\hypersetup{
            pdftitle={HEART: Using Abstract Plans As A Guarantee Of Downward Refinement In Decompositional Planning},
            pdfauthor={Antoine Gréa; Samir Aknine; Laetitia Matignon},
            pdfkeywords={Hierarchical planning, HTN, Partial Order Causal Link, POCL, Partial Order Planning, POP, Planning Algorithms},
            colorlinks=true,
            linkcolor=solarized-cyan, %%%%% PANCAKE
            filecolor=solarized-magenta, %%%%% PANCAKE
            citecolor=solarized-base1, %%%%% PANCAKE
            urlcolor=solarized-blue,
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
 %%%%% PANCAKE
  \usepackage{thmtools}
	\usepackage{nameref,cleveref}
		\crefname{section}{section}{sections}
		\crefname{table}{table}{tables}
		\crefname{listing}{listing}{listings}
		\crefname{theorem}{theorem}{theorems}
		\crefname{definition}{definition}{definitions}
		\crefname{proof}{proof}{proofs}
		\crefname{algorithm}{algorithm}{algorithms}
		\crefname{line}{line}{lines}
			\crefname{axiom}{axiom}{axioms}
	 %%%%% PANCAKE
\VerbatimFootnotes % allows verbatim text in footnotes
\usepackage{listings}
\newcommand{\passthrough}[1]{#1}
%%%%% PANCAKE
%\renewcommand\lstlistingname{\bfseries Listing} % Make listings caption title bold.
%\makeatletter
%\def\fnum@lstlisting{%
%  \lstlistingname
%  \ifx\lst@@caption\@empty\else~\thelstlisting\normalfont\fi}%
%\makeatother
\lstset{
    language=java,
    keywords={pre, eff, method, Action},
    numbers=left,
    stepnumber=1,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    keepspaces=true,
    showtabs=true,
    tabsize=1,
    extendedchars=true,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=true,
    breakautoindent=true,
%    framexrightmargin=-2mm,
    xleftmargin=5mm,
    framexleftmargin=5mm} %%%%% PANCAKE

 %%%%% PANCAKE

%%%% For listings (code blocks)
\lstset{
    basicstyle={\color{solarized-base02}\footnotesize\ttfamily},
    backgroundcolor=\color{solarized-base3},
    keywordstyle=\color{solarized-orange}\bfseries,
    identifierstyle=\color{solarized-base01},
    stringstyle=\color{solarized-green},
    commentstyle=\color{solarized-base1}\itshape,
    numberstyle=\footnotesize\color{solarized-base0}
}

 %%%%% PANCAKE
 %%%%% PANCAKE
\usepackage{longtable,booktabs}
% Fix footnotes in tables (requires footnote package)
\IfFileExists{footnote.sty}{\usepackage{footnote}\makesavenoteenv{longtable}}{}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother

\renewcommand{\and}{\quad}
\usepackage{.panzer/template/latex/SCITEPRESS}
\makeatletter
\@ifpackageloaded{subfig}{}{\usepackage{subfig}}
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\captionsetup[subfloat]{margin=0.5em}
\AtBeginDocument{%
\renewcommand*\figurename{Figure}
\renewcommand*\tablename{Table}
}
\AtBeginDocument{%
\renewcommand*\listfigurename{List of Figures}
\renewcommand*\listtablename{List of Tables}
}
\newcommand*\listoflistings\lstlistoflistings
\AtBeginDocument{%
\renewcommand*{\lstlistlistingname}{List of Listings}
}
\@ifpackageloaded{cleveref}{}{\usepackage{cleveref}}
\crefname{figure}{figure}{figures}
\Crefname{figure}{Figure}{Figures}
\crefname{table}{table}{tables}
\Crefname{table}{Table}{Tables}
\crefname{equation}{equation}{equations}
\Crefname{equation}{Equation}{Equations}
\crefname{listing}{listing}{listings}
\Crefname{listing}{Listing}{Listings}
\crefname{section}{section}{sections}
\Crefname{section}{Section}{Sections}
\makeatother

\title{HEART: Using Abstract Plans As A Guarantee Of Downward Refinement In
Decompositional Planning\thanks{Univ Lyon, Université Lyon 1, CNRS, LIRIS, UMR5205, F-69621, LYON,
France (first.lastname@liris.cnrs.fr)}}
\author{Antoine Gréa \and Samir Aknine \and Laetitia Matignon}
 %%%%% PANCAKE
\abstract{In recent years the ubiquity of artificial intelligence raised concerns
among the uninitiated. The misunderstanding is further increased since
most advances do not have explainable results. For automated planning,
the research often targets speed, quality, or expressivity. Most
existing solutions focus on one criteria while not addressing the
others. However, human-related applications require a complex
combination of all those criteria at different levels. We present a new
method to compromise on these aspects while staying explainable. We aim
to leave the range of potential applications as wide as possible but our
main targets are human intent recognition and assistive robotics. We
propose the HEART planner, a real-time decompositional planner based on
a hierarchical version of Partial Order Causal Link (POCL). It
cyclically explores the plan space while making sure that intermediary
\emph{high level plans} are valid and will return them as approximate
solutions when interrupted. These plans are proven to be a guarantee of
solvability. This paper aims to evaluate that process and its results
compared to classical approaches in terms of efficiency and quality.}
 %%%%% PANCAKE
\date{}
 %%%%% PANCAKE
\keywords{Hierarchical planning, HTN, Partial Order Causal Link, POCL, Partial Order Planning, POP, Planning Algorithms}
 %%%%% PANCAKE

\ifdefined\and %%%%% PANCAKE
\else
  \newcommand{\and}{\quad}
\fi %%%%% PANCAKE
\begin{document}
\maketitle
 %%%%% PANCAKE

 %%%%% PANCAKE

\hypertarget{introduction}{%
\section*{Introduction}\label{introduction}}
\addcontentsline{toc}{section}{Introduction}

Since the early days of automated planning, a wide variety of approaches
have been considered to solve diverse types of problems. They all range
in expressivity, speed, and reliability but often aim to excel in one of
these domains. This leads to a polarization of the solutions toward more
specialized methods to tackle each problem. All of these approaches have
been compared and discussed extensively in the books of Ghallab \emph{et
al.} (\protect\hyperlink{ref-ghallab_automated_2004}{2004},
\protect\hyperlink{ref-ghallab_automated_2016}{2016}). Partially ordered
approaches are popular for their least commitment aspect, flexibility
and ability to modify plans to use refinement operations (Weld,
\protect\hyperlink{ref-weld_introduction_1994}{1994}). These approaches
are often used in applications in robotics and multi-agent planning
(Dvorak et al., \protect\hyperlink{ref-dvorak_flexible_2014}{2014};
Lemai and Ingrand,
\protect\hyperlink{ref-lemai_interleaving_2004}{2004}). One of the most
flexible partially ordered approaches is called \emph{Partial Order
Causal Link planning (POCL)} (Young and Moore,
\protect\hyperlink{ref-young_dpocl_1994}{1994}). It works by refining
partial plans consisting of steps and causal links into a solution by
solving all flaws compromising the validity of the plan. Another
approach is \emph{Hierarchical Task Networks (HTN)} (Sacerdoti,
\protect\hyperlink{ref-sacerdoti_planning_1974}{1974}) that is meant to
tackle the problem using composite actions in order to define
hierarchical tasks within the plan. Hierarchical domains are considered
easier to conceive and maintain by experts mainly because they seem
closer to the way we think about these problems (Sacerdoti,
\protect\hyperlink{ref-sacerdoti_nonlinear_1975}{1975}). In our work, we
aim to combine HTN planning and POCL planning in such a manner as to
generate intermediary high-level plans during the planning process.
Combining these two approaches is not new (Biundo and Schattenberg,
\protect\hyperlink{ref-biundo_abstract_2001}{2001}; Kambhampati et al.,
\protect\hyperlink{ref-kambhampati_hybrid_1998}{1998}; Young and Moore,
\protect\hyperlink{ref-young_dpocl_1994}{1994}). Our work is based on
\emph{Hierarchical Partial Order Planning (HiPOP)} by Bechon \emph{et
al.} (\protect\hyperlink{ref-bechon_hipop_2014}{2014}). The idea is to
expand the classical POCL algorithm with new flaws in order to make it
compatible with HTN problems and allowing the production of abstract
plans. To do so, we present an upgraded planning framework that aims to
simplify and factorize all notions to their minimal forms. We also
propose some domain compilation techniques to reduce the work of the
expert conceiving the domain. In all these works, only the final
solution to the input problem is considered. That is a good approach to
classical planning except when no solutions can be found (or when none
exists). Our work focuses on the case when the solution could not be
found in time or when high-level explanations are preferable to the
complete implementation detail of the plan. This is done by focusing the
planning effort toward finding intermediary abstract plans along the
path to the complete solution. In the rest of the paper, we detail how
the HiErarchical Abstraction for Real-Time (HEART) planner creates
abstract intermediary plans that can be used for various applications.
First, we discuss the motivations and related works to detail the
choices behind our design process. Then we present the way we modeled
our own planning framework fitting our needs and then we explain our
method and prove its properties to finally discuss the experimental
results.

Several reasons can cause a problem to be unsolvable. The most obvious
case is that no solution exists that meets the requirements of the
problem. This has already been addressed by Göbelbecker \emph{et al.}
(\protect\hyperlink{ref-gobelbecker_coming_2010}{2010}) where
``excuses'' are being investigated as potential explanations for when a
problem has no solution. Our approach deals with problems that are too
difficult to solve within tight time constraints. For example, in
robotics, systems often need to be run within refresh rates of several
Hertz giving the process only fractions of a second to give an updated
result. Since planning is at least EXPSPACE-hard for HTN using complex
representation (Erol et al.,
\protect\hyperlink{ref-erol_htn_1994}{1994}), computing only the first
plan level of a hierarchical domain is much easier in relation to the
complete problem. While abstract plans are not complete solutions, they
still display a useful set of properties for various applications. The
most immediate application is for explainable planning (Fox et al.,
\protect\hyperlink{ref-fox_explainable_2017}{2017}; Seegebarth et al.,
\protect\hyperlink{ref-seegebarth_making_2012}{2012}). Indeed a
high-level plan is more concise and does not contain unnecessary
implementation details that would confuse a non-expert. Recent works
focus on matching the domain to a separate human model (Sreedharan,
Chakraborti, et al.,
\protect\hyperlink{ref-sreedharan_handling_2018}{2018}; Sreedharan,
Srivastava, et al.,
\protect\hyperlink{ref-sreedharan_hierarchical_2018}{2018}). This
requires the creation and maintenance of expansive human domains that
are mostly used as dictionaries to explain technical details. Our method
will give coherent high level plans that are more concise and simpler
than any classical plans. Another potential application for such plans
is relative to domains that work with approximative data. Our main
example here is intent recognition which is the original motivation for
this work. Planners are not meant to solve intent recognition problems.
However, several works extended what is called in psychology the
\emph{theory of mind}. That theory is the equivalent of asking
``\emph{what would \textbf{I} do if I was them ?}'' when observing the
behavior of other agents. This leads to new ways to use \emph{inverted
planning} as an inference tool. One of the first to propose that idea
was Baker \emph{et al.} (\protect\hyperlink{ref-baker_goal_2007}{2007})
that use Bayesian planning to infer intentions. Ramirez and Geffner
(\protect\hyperlink{ref-ramirez_plan_2009}{2009}) found an elegant way
to transform a plan recognition problem into classical planning. This is
done simply by encoding temporal constraints in the planning domain in a
similar way as Baioletti \emph{et al.}
(\protect\hyperlink{ref-baioletti_encoding_1998}{1998}) describe it to
match the observed action sequence. A cost comparison will then give a
probability of the goal to be pursued given the observations. Chen
\emph{et al.} (\protect\hyperlink{ref-chen_planning_2013}{2013})
extended this with multi-goal recognition. A new method, proposed by
Sohrabi \emph{et al.} (\protect\hyperlink{ref-sohrabi_plan_2016}{2016}),
makes the recognition fluent centric. It assigns costs to missing or
noisy observed fluents, which allows finer details and less
preprocessing work than action-based recognition. This method also uses
a meta-goal that combines each possible goal and is realized when at
least one of these goals is satisfied. Sohrabi \emph{et al.} state that
the quality of the recognition is directly linked to the quality and
domain coverage of the generated plans. Thus guided diverse
planning\footnote{Diverse planning aims to find a set of \(m\) plans
  that are distant of \(d\) from one another.} was preferred along with
the ability to infer several probable goals at once.

\hypertarget{related-works}{%
\section{Related Works}\label{related-works}}

HTN is often combined with classical approaches since it allows for a
more natural expression of domains making expert knowledge easier to
encode. These kinds of planners are named \textbf{decompositional
planners} when no initial plan is provided (Fox,
\protect\hyperlink{ref-fox_natural_1997}{1997}). Most of the time the
integration of HTN simply consists in calling another algorithm when
introducing a composite operator during the planning process. The DUET
planner by Gerevini \emph{et al.}
(\protect\hyperlink{ref-gerevini_combining_2008}{2008}) does so by
calling an instance of a HTN planner based on task insertion called
SHOP2 (Nau et al., \protect\hyperlink{ref-nau_shop2_2003}{2003}) to
decompose composite actions. Some planners take the integration further
by making the decomposition of composite actions into a special step in
their refinement process. Such works include the discourse generation
oriented DPOCL (Young and Moore,
\protect\hyperlink{ref-young_dpocl_1994}{1994}) and the work of
Kambhampati \emph{et al.}
(\protect\hyperlink{ref-kambhampati_hybrid_1998}{1998}) generalizing the
practice for decompositional planners. In our case, we chose a class of
hierarchical planners based on Plan-Space Planning (PSP) algorithms
(Bechon et al., \protect\hyperlink{ref-bechon_hipop_2014}{2014}; Bercher
et al., \protect\hyperlink{ref-bercher_hybrid_2014}{2014}; Dvorak et
al., \protect\hyperlink{ref-dvorak_flexible_2014}{2014}) as a reference
approach. The main difference here is that the decomposition is
integrated into the classical POCL algorithm by only adding new types of
flaws. This allows keeping all the flexibility and properties of POCL
while adding the expressivity and abstraction capabilities of HTN. We
also made an improved planning framework based on the one used by HiPOP
to reduce further the number of changes needed to handle composite
actions and to increase the efficiency of the resulting implementation.
As stated previously, our goal is to obtain intermediary abstract plans
and to evaluate their properties. Another work has already been done on
another aspect of those types of plans. The Angelic algorithm by Marthi
\emph{et al.} (\protect\hyperlink{ref-marthi_angelic_2007}{2007})
exploited such plans in the planning process itself and used them as a
heuristic guide. They also proved that, for a given fluent semantics, it
is guaranteed that such abstract solutions can be refined into actual
solutions. However, the Angelic planner does not address the inherent
properties of such abstract plans as approximate solutions and uses a
more restrictive totally ordered framework.

\hypertarget{definitions}{%
\section{Definitions}\label{definitions}}

In order to make the notations used in the paper more understandable, we
gathered them in table \ref{tbl:symbols}. For domain and problem
representation, we use a custom knowledge description language that is
inspired from RDF Turtle (Beckett and Berners-Lee,
\protect\hyperlink{ref-beckett_turtle_2011}{2011}) and is based on
triples and propositional logic. In that language quantifiers are used
to quantify variables \passthrough{\lstinline!*(x)!} (forall x) but can
also be simplified with an implicit form:
\passthrough{\lstinline!lost(\~)!} meaning \emph{" nothing is
lost``\emph{. For reference, the \emph{exclusive quantifier} we
introduced (noted \passthrough{\lstinline!\~!}) is used for the negation
(e.g.~\passthrough{\lstinline!\~(lost(\_))!} for }'' something is not
lost"}) as well as the symbol for nil. All symbols are defined as they
are first used. If a symbol is used as a parameter and is referenced
again in the same statement, it becomes a variable.

\hypertarget{tbl:symbols}{}
\begin{table}\footnotesize
\centering

\caption{\label{tbl:symbols}Our notations are adapted from Ghallab
\emph{et al.} (\protect\hyperlink{ref-ghallab_automated_2004}{2004}).
The symbol \(\pm\) shows when the notation has signed variants.}

\begin{tabular}{@{}ll@{}}
\toprule

\textbf{Symbol} & \textbf{Description} \\\midrule

\(\mathcal{D}, \mathcal{P}\) & Planning domain and problem. \\
\(\mathit{pre}(a)\), \(\mathit{eff}(a)\) & Preconditions and effects of
the action \(a\). \\
\(\mathit{methods}(a)\) & Methods of the action \(a\). \\
\(\phi^\pm(l)\) & Signed incidence function: \\
 & \(\phi^-\) gives the source and \(\phi^+\) the target step of
\(l\). \\
 & No sign gives a pair corresponding to link \(l\). \\
\(L^\pm(a)\) & Set of incoming (\(L^-\)) and \\
 & outgoing (\(L^+\)) links of step \(a\). \\
 & No sign gives all adjacent links. \\
\(a_s \xrightarrow{c} a_t\) & Link with source \(a_s\), target \(a_t\)
and cause \(c\). \\
\(\mathit{causes}(l)\) & Gives the causes of a causal link \(l\). \\
\(a_a \succ a_s\) & A step \(a_a\) is anterior to the step \(a_s\). \\
\(A_x^n\) & Proper actions set of \(x\) down \(n\) levels. \\
\(lv(x)\) & Abstraction level of the entity \(x\). \\
\(a \rhd^\pm a'\) & Transpose the links of action \(a\) onto \(a'\). \\
\(l \downarrow a\) & Link \(l\) partially supports step \(a\). \\
\(\pi \Downarrow a\) & Plan \(\pi\) fully supports \(a\). \\
\(\downarrowbarred_f a\) & Subgoal: fluent \(f\) not supported in step
\(a\). \\
\(a_b \olcross l\) & Threat: action \(a_b\) threatens causal link
\(l\). \\
\(a \oplus^m\) & Decomposition of action \(a\) using method \(m\). \\
\(var: exp\) & The colon is to be read as ``such that''. \\
\([exp]\) & Iverson's brackets: \\
 & \(0\) if \(exp\) is false, \(1\) otherwise. \\

\bottomrule
\end{tabular}

\end{table}

The domain specifies the allowed operators that can be used to plan and
all the fluents they use as preconditions and effects.

\begin{definition}[Domain]

A domain is a triplet
\(\mathcal{D} = \langle E_{\mathcal{D}}, R, A_{\mathcal{D}} \rangle\)
where:

\begin{itemize}
\tightlist
\item
  \(E_{\mathcal{D}}\) is the set of \textbf{domain entities}.
\item
  \(R\) is the set of \textbf{relations} over \(E_{\mathcal{D}}^n\).
  These relations are akin to n-ary predicates in first order logic.
\item
  \(A_{\mathcal{D}}\) is the set of \textbf{operators} which are fully
  lifted \emph{actions}.
\end{itemize}

\end{definition}

\emph{Example:} The example domain in listing \ref{lst:domain} is
inspired from the kitchen domain of Ramirez and Geffner
(\protect\hyperlink{ref-ramirez_probabilistic_2010}{2010}).

\begin{lstlisting}[caption={Domain file used in our planner.}, label=lst:domain]
take(item) pre (taken(~), ?(item)); //?(item) is used to make item into a variable.
take(item) eff (taken(item));
heat(thing) pre (~(hot(thing)), taken(thing));
heat(thing) eff (hot(thing));
pour(thing, into) pre (thing ~(in) into, taken(thing));
pour(thing, into) eff (thing in into);
put(utensil) pre (~(placed(utensil)), taken(utensil));
put(utensil) eff (placed(utensil), ~(taken(utensil)));

infuse :: Action;
make :: Action;
\end{lstlisting}

\begin{definition}[Fluent]

A fluent \(f\) is a parameterized statement
\(r(arg_1, arg_2, …, arg_n)\) where:

\begin{itemize}
\tightlist
\item
  \(r \in R\) is a relation/function holding a property of the world.
\item
  \(arg_{i \in [1,n]} \in E_{\mathcal{D}}\) are the arguments (possibly
  quantified).
\item
  \(n = |r|\) is the arity of \(r\).
\end{itemize}

Fluents are signed. Negative fluents are noted \(\neg f\) and behave as
a logical complement. The quantifiers are affected by the sign of the
fluents. We do not use the closed world hypothesis: fluents are only
satisfied when another compatible fluent is provided. Sets of fluents
have a boolean value that equals the conjunction of all its fluents.

\end{definition}

\emph{Example:} To describe an item not being held, we use the fluent
\(\neg taken(item)\). If the cup contains water, \(in(water, cup)\) is
true.

\begin{definition}[Partial Plan / Method]

A partially ordered plan is an \emph{acyclic} directed graph
\(\pi = (S, L)\), with:

\begin{itemize}
\tightlist
\item
  \(S\) the set of \textbf{steps} of the plan as vertices. A step is an
  action belonging in the plan. \(S\) must contain an initial step
  \(I_\pi\) and goal step \(G_\pi\).
\item
  \(L\) the set of \textbf{causal links} of the plan as edges. We note
  \(l = a_s \xrightarrow{c} a_t\) the link between its source \(a_s\)
  and its target \(a_t\) caused by the set of fluents \(c\). If
  \(c = \emptyset\) then the link is used as an ordering constraint.
\end{itemize}

\end{definition}

In our framework, \emph{ordering constraints} are defined as the
transitive cover of causal links over the set of steps. We note ordering
constraints: \(a_a \succ a_s\), with \(a_a\) being \emph{anterior} to
its \emph{successor} \(a_s\). Ordering constraints cannot form cycles,
meaning that the steps must be different and that the successor cannot
also be anterior to its anterior steps:
\(a_a \neq a_s \land a_s \not \succ a_a\). In all plans, the initial and
goal steps have their order guaranteed:
\(I_\pi \succ G\pi \land \nexists a_x \in S_\pi: a_x \succ I_\pi \lor G_\pi \succ a_x\).
If we need to enforce order, we simply add a link without specifying a
cause. The use of graphs and implicit order constraints help to simplify
the model while maintaining its properties.

The central notion of planning is operators. Instantiated operators are
usually called \emph{actions}. In our framework, actions can be
partially instantiated. We use the term action for both lifted and
grounded operators.

\begin{definition}[Action]\label[definition]{def:action}

An action is a parametrized tuple
\(a(args)=\langle name, pre, \mathit{eff}, methods \rangle\) where:

\begin{itemize}
\tightlist
\item
  \(name\) is the \textbf{name} of the action.
\item
  \(\mathit{pre}\) and \(\mathit{eff}\) are sets of fluents that are
  respectively the \textbf{preconditions and the effects} of the action.
\item
  \(methods\) is a set of \textbf{methods} (\emph{partial order plans})
  that decompose the action into smaller ones. Methods, and the methods
  of their enclosed actions, cannot contain the parent action.
\end{itemize}

\end{definition}

\emph{Example:} The precondition of the operator \(take(item)\) is
simply a single negative fluent noted \(\neg taken(item)\) ensuring the
variable \(item\) is not already taken.

\emph{Composite} actions are represented using methods. An action
without methods is called \emph{atomic}. It is of interest to note the
divergence with classical HTN representation here since normally
composite actions do not have preconditions nor effects. In our case, we
insert them into abstract plans.

In order to simplify the input of the domain, the causes of the causal
links in the methods are optional. If omitted, the causes are inferred
by unifying the preconditions and effects with the same mechanism as in
the subgoal resolution in our POCL algorithm. Since we want to guarantee
the validity of abstract plans, we need to ensure that user provided
plans are solvable. We use the following formula to compute the final
preconditions and effects of any composite action \(a\):
\(\mathit{pre}(a) = \bigcup_{l \in L^+(I_m)}^{m \in methods(a)} \mathit{causes}(l)\)
and
\(\mathit{eff}(a) = \bigcup_{l \in L^-(G_m))}^{m \in methods(a)} \mathit{causes}(l)\).
An instance of the classical POCL algorithm is then run on the problem
\(\mathcal{P}_a = \langle \mathcal{D}, C_{\mathcal{P}} , a\rangle\) to
ensure its coherence. The domain compilation fails if POCL cannot be
completed. Since our decomposition hierarchy is acyclic
(\(a \notin A_a\), see definition \ref{def:proper}) nested methods
cannot contain their parent action as a step.

Problem instances are often most simply described by two components: the
initial state and the goal.

\begin{definition}[Problem]

The planning problem is defined as a tuple
\(\mathcal{P} = \langle \mathcal{D}, C_{\mathcal{P}} , a_0\rangle\)
where:

\begin{itemize}
\tightlist
\item
  \(\mathcal{D}\) is a planning domain.
\item
  \(C_{\mathcal{P}}\) is the set of \textbf{problem constants} disjoint
  from the domain constants.
\item
  \(a_0\) is the \textbf{root operator} of the problem which methods are
  potential solutions of the problem.
\end{itemize}

\end{definition}

\emph{Example:} We use a simple problem for our example domain. The
initial state provides that nothing is ready, taken or hot and all
containers are empty (all using quantifiers). The goal is to have tea
made. For reference, listing \ref{lst:problem} contains the problem
instance we use as an example.

\begin{lstlisting}[caption={Example of a problem instance for the kitchen domain.}, label=lst:problem]
init eff (hot(~), taken(~), placed(~), ~ in ~);
goal pre (hot(water), tea in cup, water in cup, placed(spoon), placed(cup));
\end{lstlisting}

The root operator is initialized to
\(a_0 = \langle "", s_0, s^*, \lbrace \pi_{lv(a_0)} \rbrace\rangle\),
with \(s_0\) being the initial state and \(s^*\) the goal specification.
The method \(\pi_{lv(a_0)}\) is a partial order plan with the initial
and goal steps linked together via \(a_0\). The initial partial order
plan is
\(\pi_{lv(a_0)} = (\lbrace I,G \rbrace, \lbrace I \xrightarrow{s_0} a_0 \xrightarrow{s^*} G \rbrace)\),
with \(I = \langle "init", \emptyset, s_0, \emptyset\rangle\) and
\(G = \langle "goal", s^*, \emptyset, \emptyset\rangle\).

Our method is based on the classical POCL algorithm. It works by
refining a partial plan into a solution by recursively removing all of
its flaws.

\begin{definition}[Flaws]

Flaws have a \emph{proper fluent} \(f\) and a causing step often called
the \emph{needer} \(a_n\). Flaws in a partial plan are either:

\begin{itemize}
\tightlist
\item
  \textbf{Subgoals}, \emph{open conditions} that are yet to be supported
  by another step \(a_n\) often called \emph{provider}. We note subgoals
  \(\downarrowbarred_f a_n\).
\item
  \textbf{Threats}, caused by steps that can break a causal link with
  their effects. They are called \emph{breakers} of the threatened link.
  A step \(a_b\) threatens a causal link
  \(l_t = a_p \xrightarrow{f} a_n\) if and only if
  \(\neg f \in \mathit{eff}(a_b) \land a_b \not\succ a_p \land a_n \not\succ a_b\).
  Said otherwise, the breaker can cancel an effect of a providing step
  \(a_p\), before it gets used by its needer \(a_n\). We note threats
  \(a_b \olcross l_t\).
\end{itemize}

\end{definition}

\emph{Example:} Our initial plan contains two unsupported subgoals: one
to make the tea ready and another to put sugar in it. In this case, the
needer is the goal step and the proper fluents are each of its
preconditions.

These flaws need to be fixed in order for the plan to be valid. In POCL
it is done by finding their resolvers.

\begin{definition}[Resolvers]\label[definition]{def:resolvers}

Classical resolvers are additional causal links that aim to fix a flaw.

\begin{itemize}
\tightlist
\item
  \emph{For subgoals}, the resolvers are a set of potential causal links
  containing the proper fluent \(f\) in their causes while taking the
  needer step \(a_n\) as their target and a \textbf{provider} step
  \(a_p\) as their source.
\item
  \emph{For threats}, we usually consider only two resolvers:
  \textbf{demotion} (\(a_b \succ a_p\)) and \textbf{promotion}
  (\(a_n \succ a_b\)) of the breaker relative to the threatened link. We
  call the added causeless causal link a \textbf{guarding} link.
\end{itemize}

Negative resolvers are resolvers that will delete causal links to fix a
flaw. These are needed for decomposition
definition \ref{def:decomposition}.

\end{definition}

\emph{Example:} The subgoal for \(in( water, cup )\), in our example,
can be solved by using the action \(pour(water, cup)\) as the source of
a causal link carrying the proper fluent as its only cause.

The application of a resolver does not necessarily mean progress. It can
have consequences that may require reverting its application in order to
respect the backtracking of the POCL algorithm.

\begin{definition}[Side effects]\label[definition]{def:side-effects}

Flaws that are caused by the application of a resolver are called
\emph{related flaws}. They are inserted into the \emph{agenda}\footnote{An
  agenda is a flaw container used for the flaw selection of POCL.} with
each application of a resolver:

\begin{itemize}
\tightlist
\item
  \emph{Related subgoals} are all the new open conditions inserted by
  new steps.
\item
  \emph{Related threats} are the causal links threatened by the
  insertion of a new step or the deletion of a guarding link.
\end{itemize}

Flaws can also become irrelevant when a resolver is applied. It is
always the case for the targeted flaw, but this can also affect other
flaws. Those \emph{invalidated flaws} are removed from the agenda upon
detection:

\begin{itemize}
\tightlist
\item
  \emph{Invalidated subgoals} are subgoals satisfied by the new causal
  links or the removal of their needer.
\item
  \emph{Invalidated threats} happen when the breaker no longer threatens
  the causal link because the order guards the threatened causal link or
  either of them has been removed.
\end{itemize}

\end{definition}

\emph{Example:} Adding the action \(pour(water, cup)\) causes a related
subgoal for each of the preconditions of the action which are: the cup
and the water must be taken and water must not already be in the cup.

In definition \ref{def:resolvers}, we mentioned effects that aren't
present in classical POCL, namely \emph{negative resolvers}. All
classical resolvers only add steps and causal links to the partial plan.
Our method needs to remove composite steps and their adjacent links when
expanding them.

\hypertarget{the-heart-of-the-method}{%
\section{The Heart of the Method}\label{the-heart-of-the-method}}

In this section, we explain how our method combines POCL with HTN
planning and how they are used to generate intermediary abstract plans.
In order to properly introduce the changes made for using HTN domains in
POCL, we need to define a few notions. Transposition is needed to define
decomposition.

\begin{definition}[Transposition]

In order to transpose the causal links of an action \(a'\) with the ones
of an existing step \(a\) in a plan \(\pi\), we use the following
operation:

\[a \rhd^-_\pi a' = \left \lbrace \phi^-(l) \xrightarrow{\mathit{causes}(l)} a': l \in L^-_\pi(a) \right \rbrace\]

It is the same with \(a' \xrightarrow{\mathit{causes}(l)} \phi^+(l)\)
and \(L^+\) for \(a \rhd^+ a'\). This supposes that the respective
preconditions and effects of \(a\) and \(a'\) are equivalent. When not
signed, the transposition is generalized:
\(a \rhd a' = a\rhd^-a' \cup a\rhd^+a'\).

\end{definition}

\emph{Example:} \(a\rhd^-a'\) gives all incoming links of \(a\) with the
\(a\) replaced by \(a'\).

\begin{definition}[Proper Actions]\label[definition]{def:proper}

Proper actions are actions that are ``contained'' within an entity
(either a domain, plan or action). We note this notion
\(A_a = A_a^{lv(a)}\) for an action \(a\). It can be applied to various
concepts:

\begin{itemize}
\tightlist
\item
  For a \emph{domain} or a \emph{problem},
  \(A_{\mathcal{P}} = A_{\mathcal{D}}\).
\item
  For a \emph{plan}, it is \(A^0_\pi = S_\pi\).
\item
  For an \emph{action}, it is
  \(A^0_a = \bigcup_{m \in \mathit{methods}(a)} S_m\). Recursively:
  \(A_a^n = \bigcup_{b\in A_a^0} A_{b}^{n-1}\). For atomic actions,
  \(A_a = \emptyset\).
\end{itemize}

\end{definition}

\emph{Example:} The proper actions of \(make(drink)\) are the actions
contained within its methods. The set of extended proper actions adds
all proper actions of its single proper composite action
\(infuse(drink, water, cup)\).

\begin{definition}[Abstraction Level]\label[definition]{def:level}

This is a measure of the maximum amount of abstraction an entity can
express, defined recursively by:\footnote{We use Iverson brackets here,
  see notations in table \ref{tbl:symbols}.}
\[lv(x) = \left ( \max_{a \in A_x}(lv(a)) + 1 \right ) [A_x \neq \emptyset]\]

\end{definition}

\emph{Example:} The abstraction level of any atomic action is \(0\)
while it is \(2\) for the composite action \(make(drink)\). The example
domain (in listing \ref{lst:domain}) has an abstraction level of \(3\).

The most straightforward way to handle abstraction in regular planners
is illustrated by Duet (Gerevini et al.,
\protect\hyperlink{ref-gerevini_combining_2008}{2008}) by managing
hierarchical actions separately from a task insertion planner. We chose
to add abstraction in POCL in a manner inspired by the work of Bechon
\emph{et al.} (\protect\hyperlink{ref-bechon_hipop_2014}{2014}) on a
planner called HiPOP. The difference between the original HiPOP and our
implementation of it is that we focus on the expressivity and the ways
flaw selection can be exploited for partial resolution. Our version is
lifted at runtime while the original is grounded for optimizations. All
mechanisms we have implemented use POCL but with different management of
flaws and resolvers. The original algorithm \ref{alg:pocl} is left
untouched.

One of those changes is that resolver selection needs to be altered for
subgoals. Indeed, as stated by the authors of HiPOP: the planner must
ensure the selection of high-level operators in order to benefit from
the hierarchical aspect of the domain. Otherwise, adding operators only
increases the branching factor. Composite actions are not usually meant
to stay in a finished plan and must be decomposed into atomic steps from
one of their methods.

\begin{definition}[Decomposition Flaws]\label[definition]{def:decomposition}

They occur when a partial plan contains a non-atomic step. This step is
the needer \(a_n\) of the flaw. We note its decomposition
\(a_n \oplus\).

\begin{itemize}
\tightlist
\item
  \emph{Resolvers:} A decomposition flaw is solved with a
  \textbf{decomposition resolver}. The resolver will replace the needer
  with one of its instantiated methods \(m \in \mathit{methods}(a_n)\)
  in the plan \(\pi\). This is done by using transposition such that:
  \(a_n \oplus^m_\pi = \langle S_m \cup (S_\pi \setminus \lbrace a \rbrace) , a_n \rhd^- I_m \cup a_n \rhd^+ G_m \cup (L_\pi \setminus L_\pi(a_n))\).
\item
  \emph{Side effects:} A decomposition flaw can be created by the
  insertion of a composite action in the plan by any resolver and
  invalidated by its removal:
  \[\bigcup^{f \in \mathit{pre}(a_m)}_{a_m \in S_m} \pi' \downarrowbarred_f a_m\bigcup^{l \in L_{\pi'}}_{a_b \in S_{\pi'}} a_b \olcross l \bigcup_{a_c \in S_m}^{lv(a_c) \neq 0} a_c \oplus\]
\end{itemize}

\end{definition}

\emph{Example:} When adding the step \(make(tea)\) in the plan to solve
the subgoal that needs tea being made, we also introduce a decomposition
flaw that will need this composite step replaced by its method using a
decomposition resolver. In order to decompose a composite action into a
plan, all existing links are transposed to the initial and goal step of
the selected method, while the composite action and its links are
removed from the plan. The main differences between HiPOP and HEART in
our implementations are the functions of flaw selection and the handling
of the results (one plan for HiPOP and a plan per cycle for HEART). In
HiPOP, the flaw selection is made by prioritizing the decomposition
flaws. Bechon \emph{et al.}
(\protect\hyperlink{ref-bechon_hipop_2014}{2014}) state that it makes
the full resolution faster. However, it also loses opportunities to
obtain abstract plans in the process.

\begin{figure}
\hypertarget{fig:cycles}{%
\centering
\includegraphics{graphics/cycles.svg}
\caption{Illustration of how the cyclical approach is applied on the
example domain. Atomic actions that are copied from a cycle to the next
are omitted.}\label{fig:cycles}
}
\end{figure}

The main focus of our work is toward obtaining \textbf{abstract plans}
which are plans that are completed while still containing composite
actions. In order to do that the flaw selection function will enforce
cycles in the planning process.

\begin{definition}[Cycle]

A cycle is a planning phase defined as a triplet
\(c = \langle lv(c), agenda, \pi_{lv(c)}\rangle\) where: \(lv(c)\) is
the maximum abstraction level allowed for flaw selection in the
\(agenda\) of remaining flaws in partial plan \(\pi_{lv(c)}\). The
resolvers of subgoals are therefore constrained by the following:
\(a_p \downarrow_f a_n: lv(a_p) \leq lv(c)\).

\end{definition}

During a cycle all decomposition flaws are delayed. Once no more flaws
other than decomposition flaws are present in the agenda, the current
plan is saved and all remaining decomposition flaws are solved at once
before the abstraction level is lowered for the next cycle:
\(lv(c') = lv(c)-1\). Each cycle produces a more detailed abstract plan
than the one before.

Abstract plans allow the planner to do an approximate form of anytime
execution. At any given time the planner is able to return a fully
supported plan. Before the first cycle, the plan returned is
\(\pi_{lv(a_0)}\).

\emph{Example:} In our case using the method of intent recognition of
Sohrabi \emph{et al.} Sohrabi et al.
(\protect\hyperlink{ref-sohrabi_plan_2016}{2016}), we can already use
\(\pi_{lv(a_0)}\) to find a likely goal explaining an observation (a set
of temporally ordered fluents). That can make an early assessment of the
probability of each goal of the recognition problem.

For each cycle \(c\), a new plan \(\pi_{lv(c)}\) is created as a new
method of the root operator \(a_0\). These intermediary plans are not
solutions of the problem, nor do they mean that the problem is solvable.
In order to find a solution, the HEART planner needs to reach the final
cycle \(c_0\) with an abstraction level \(lv(c_0) = 0\). However, these
plans can be used to derive meaning from the potential solution of the
current problem and give a good approximation of the final result before
its completion.

\emph{Example:} In the \cref{fig:cycles}, we illustrate the way our
problem instance is progressively solved. Before the first cycle
\(c_2\), all we have is the root operator and its plan \(\pi_3\). Then
within the first cycle, we select the composite action \(make(tea)\)
instantiated from the operator \(make(drink)\) along with its methods.
All related flaws are fixed until all that is left in the agenda is the
abstract flaws. We save the partial plan \(\pi_2\) for this cycle and
expand \(make(tea)\) into a copy of the current plan \(\pi_1\) for the
next cycle. The solution of the problem will be stored in \(\pi_0\) once
found.

\hypertarget{results}{%
\section{Results}\label{results}}

The completeness and soundness of POCL has been proven in (Penberthy et
al., \protect\hyperlink{ref-penberthy_ucpop_1992}{1992}). An interesting
property of POCL algorithms is that flaw selection strategies do not
impact these properties. Since the only modification of the algorithm is
the extension of the classical flaws with a decomposition flaw, all we
need to explore, to update the proofs, is the impact of the new
resolver. By definition, the resolvers of decomposition flaws will take
into account all flaws introduced by its resolution into the refined
plan. It can also revert its application properly.

\begin{lemma}[Decomposing preserves acyclicity]

The decomposition of a composite action with a valid method in an
acyclic plan will result in an acyclic plan. Formely,
\(\forall a_s \in S_\pi: a_s \nsucc_\pi a_s \implies \forall a'_s \in S_{a \oplus^m_\pi}: a'_s \nsucc_{a \oplus^m_\pi} a'_s\).

\end{lemma}

\begin{proof}

When decomposing a composite action \(a\) with a method \(m\) in an
existing plan \(\pi\), we add all steps \(S_m\) in the refined plan.
Both \(\pi\) and \(m\) are guaranteed to be cycle free by definition. We
can note that
\(\forall a_s \in S_m: \left ( \nexists a_t \in S_m: a_s \succ a_t \land \lnot f \in \mathit{eff}(a_t)\right ) \implies f \in \mathit{eff}(a)\).
Said otherwise, if an action \(a_s\) can participate a fluent \(f\) to
the goal step of the method \(m\) then it is necessarily present in the
effects of \(a\). Since higher level actions are preferred during the
resolver selection, no actions in the methods are already used in the
plan when the decomposition happens. This can be noted
\(\exists a \in \pi \implies S_m \cupdot S_\pi\) meaning that in the
graph formed both partial plans \(m\) and \(\pi\) cannot contain the
same edges therefore their acyclicity is preserved when inserting one
into the other. \hfill \qed

\end{proof}

\begin{lemma}[Solved decomposition flaws cannot reoccur]

The application of a decomposition resolver on a plan \(\pi\),
guarantees that \(a \notin S_{\pi'}\) for any partial plan refined from
\(\pi\) without reverting the application of the resolver.

\end{lemma}

\begin{proof}

As stated in the definition of the methods
definition \ref{def:action}:~\(a \notin A_a\). This means that \(a\)
cannot be introduced in the plan by its decomposition or the
decomposition of its proper actions. Indeed, once \(a\) is expanded, the
level of the following cycle \(c_{lv(a)-1}\) prevents \(a\) to be
selected by subgoal resolvers. It cannot either be contained in the
methods of another action that are selected afterward because otherwise
following definition \ref{def:level} its level would be at least
\(lv(a)+1\). \hfill \qed

\end{proof}

\begin{lemma}[Decomposing to abstraction level 0 guarantees solvability]

Finding a partial plan that contains only decomposition flaws with
actions of abstraction level 1, guarantees a solution to the problem.

\end{lemma}

\begin{proof}

Any method \(m\) of a composite action \(a: lv(a) = 1\) is by definition
a solution of the problem
\(\mathcal{P}_a = \langle \mathcal{D}, C_{\mathcal{P}} , a\rangle\). By
definition, \(a \notin A_a\), and \(a \notin A_{a \oplus^m_\pi}\)
(meaning that \(a\) cannot reoccur after being decomposed). It is also
given by definition that the instantiation of the action and its methods
are coherent regarding variable constraints (everything is instantiated
before selection by the resolvers). Since the plan \(\pi\) only has
decomposition flaws and all flaws within \(m\) are guaranteed to be
solvable, and both are guaranteed to be acyclical by the application of
any decomposition \(a \oplus^m_\pi\), the plan is solvable. \hfill \qed

\end{proof}

\begin{lemma}[Abstract plans guarantee solvability]

Finding a partial plan \(\pi\) that contains only decomposition flaws,
guarantees a solution to the problem.

\end{lemma}

\begin{proof}

Recursively, if we apply the previous proof on higher level plans we
note that decomposing at level 2 guarantees a solution since the method
of the composite actions are guaranteed to be solvable. \hfill \qed

\end{proof}

\hypertarget{conclusion}{%
\section*{Conclusion}\label{conclusion}}
\addcontentsline{toc}{section}{Conclusion}

In this paper, we have presented a new planner called HEART based on
POCL. An updated planning framework fitting the need for such a new
approach was proposed. While the abstract plans generated during the
planning process are not complete solutions, they are exponentially
faster to generate while retaining significant quality over the final
plans. They are also proofs of solvability of the problem. By using
these plans, it is possible to generate explanations of intractable
problems within tight time constraints.

The source code of HEART along with an extended version of this paper is
available at \href{https://genn.io/heart}{genn.io/heart}.

\hypertarget{references}{%
\section*{References}\label{references}}
\addcontentsline{toc}{section}{References}

\setlength{\parindent}{0in}
\setlength{\leftskip}{0in}
\small

\noindent

\hypertarget{refs}{}
\leavevmode\hypertarget{ref-baioletti_encoding_1998}{}%
Baioletti, M., Marcugini, S., and Milani, A. (1998). Encoding planning
constraints into partial order planning domains. In \emph{International
Conference on Principles of Knowledge Representation and Reasoning},
pages 608--616. Morgan Kaufmann Publishers Inc.

\leavevmode\hypertarget{ref-baker_goal_2007}{}%
Baker, C. L., Tenenbaum, J. B., and Saxe, R. R. (2007). Goal inference
as inverse planning. In \emph{Proceedings of the Annual Meeting of the
Cognitive Science Society},Vol. 29.

\leavevmode\hypertarget{ref-bechon_hipop_2014}{}%
Bechon, P., Barbier, M., Infantes, G., Lesire, C., and Vidal, V. (2014).
HiPOP: Hierarchical Partial-Order Planning. In \emph{European Starting
AI Researcher Symposium},Vol. 264, pages 51--60. IOS Press.

\leavevmode\hypertarget{ref-beckett_turtle_2011}{}%
Beckett, D., and Berners-Lee, T. (2011). \emph{Turtle - Terse RDF Triple
Language} (W3C Team Submission). W3C.

\leavevmode\hypertarget{ref-bercher_hybrid_2014}{}%
Bercher, P., Keen, S., and Biundo, S. (2014). Hybrid planning heuristics
based on task decomposition graphs. In \emph{Seventh Annual Symposium on
Combinatorial Search}.

\leavevmode\hypertarget{ref-biundo_abstract_2001}{}%
Biundo, S., and Schattenberg, B. (2001). From abstract crisis to
concrete relief preliminary report on flexible integration on nonlinear
and hierarchical planning. In \emph{Proceedings of the European
Conference on Planning}.

\leavevmode\hypertarget{ref-chen_planning_2013}{}%
Chen, J., Chen, Y., Xu, Y., Huang, R., and Chen, Z. (2013). A Planning
Approach to the Recognition of Multiple Goals. \emph{International
Journal of Intelligent Systems}, \emph{28}(3), 203--216.

\leavevmode\hypertarget{ref-dvorak_flexible_2014}{}%
Dvorak, F., Bit-Monnot, A., Ingrand, F., and Ghallab, M. (2014). A
flexible ANML actor and planner in robotics. In \emph{Planning and
Robotics (PlanRob) Workshop (ICAPS)}.

\leavevmode\hypertarget{ref-erol_htn_1994}{}%
Erol, K., Hendler, J., and Nau, D. S. (1994). HTN planning: Complexity
and expressivity. In \emph{AAAI},Vol. 94, pages 1123--1128.

\leavevmode\hypertarget{ref-fox_natural_1997}{}%
Fox, M. (1997). Natural hierarchical planning using operator
decomposition. In \emph{European Conference on Planning}, pages
195--207. Springer.

\leavevmode\hypertarget{ref-fox_explainable_2017}{}%
Fox, M., Long, D., and Magazzeni, D. (2017). Explainable Planning. In
\emph{Proceedings of IJCAI Workshop on Explainable AI}. Melbourne,
Australia.

\leavevmode\hypertarget{ref-gerevini_combining_2008}{}%
Gerevini, A., Kuter, U., Nau, D. S., Saetti, A., and Waisbrot, N.
(2008). Combining Domain-Independent Planning and HTN Planning: The Duet
Planner. In \emph{Proceedings of the European Conference on Artificial
Intelligence},Vol. 18, pages 573--577.

\leavevmode\hypertarget{ref-ghallab_automated_2004}{}%
Ghallab, M., Nau, D., and Traverso, P. (2004). \emph{Automated planning:
Theory \& practice}. Elsevier.

\leavevmode\hypertarget{ref-ghallab_automated_2016}{}%
Ghallab, M., Nau, D., and Traverso, P. (2016). \emph{Automated Planning
and Acting}. Cambridge University Press.

\leavevmode\hypertarget{ref-gobelbecker_coming_2010}{}%
Göbelbecker, M., Keller, T., Eyerich, P., Brenner, M., and Nebel, B.
(2010). Coming Up With Good Excuses: What to do When no Plan Can be
Found. In \emph{Proceedings of the International Conference on Automated
Planning and Scheduling},Vol. 20, pages 81--88. AAAI Press.

\leavevmode\hypertarget{ref-kambhampati_hybrid_1998}{}%
Kambhampati, S., Mali, A., and Srivastava, B. (1998). Hybrid planning
for partially hierarchical domains. In \emph{AAAI/IAAI}, pages 882--888.

\leavevmode\hypertarget{ref-lemai_interleaving_2004}{}%
Lemai, S., and Ingrand, F. (2004). Interleaving temporal planning and
execution in robotics domains. In \emph{AAAI},Vol. 4, pages 617--622.

\leavevmode\hypertarget{ref-marthi_angelic_2007}{}%
Marthi, B., Russell, S. J., and Wolfe, J. A. (2007). Angelic Semantics
for High-Level Actions. In \emph{ICAPS}, pages 232--239.

\leavevmode\hypertarget{ref-nau_shop2_2003}{}%
Nau, D. S., Au, T.-C., Ilghami, O., Kuter, U., Murdock, J. W., Wu, D.,
and Yaman, F. (2003). SHOP2: An HTN planning system. \emph{J. Artif.
Intell. Res.(JAIR)}, \emph{20}, 379--404.

\leavevmode\hypertarget{ref-penberthy_ucpop_1992}{}%
Penberthy, J. S., Weld, D. S., and others. (1992). UCPOP: A Sound,
Complete, Partial Order Planner for ADL. \emph{Kr}, \emph{92}, 103--114.

\leavevmode\hypertarget{ref-ramirez_plan_2009}{}%
Ramırez, M., and Geffner, H. (2009). Plan recognition as planning. In
\emph{Proceedings of the International Conference on International
Conference on Automated Planning and Scheduling},Vol. 19, pages
1778--1783. AAAI Press.

\leavevmode\hypertarget{ref-ramirez_probabilistic_2010}{}%
Ramırez, M., and Geffner, H. (2010). Probabilistic plan recognition
using off-the-shelf classical planners. In \emph{Proceedings of the
Conference of the Association for the Advancement of Artificial
Intelligence},Vol. 24, pages 1121--1126.

\leavevmode\hypertarget{ref-sacerdoti_planning_1974}{}%
Sacerdoti, E. D. (1974). Planning in a hierarchy of abstraction spaces.
\emph{Artificial Intelligence}, \emph{5}(2), 115--135.

\leavevmode\hypertarget{ref-sacerdoti_nonlinear_1975}{}%
Sacerdoti, E. D. (1975). \emph{The nonlinear nature of plans}. STANFORD
RESEARCH INST MENLO PARK CA.

\leavevmode\hypertarget{ref-seegebarth_making_2012}{}%
Seegebarth, B., Müller, F., Schattenberg, B., and Biundo, S. (2012).
Making hybrid plans more clear to human usersa formal approach for
generating sound explanations. In \emph{Proceedings of the Twenty-Second
International Conference on International Conference on Automated
Planning and Scheduling}, pages 225--233. AAAI Press.

\leavevmode\hypertarget{ref-sohrabi_plan_2016}{}%
Sohrabi, S., Riabov, A. V., and Udrea, O. (2016). Plan Recognition as
Planning Revisited. In \emph{Proceedings of the International Joint
Conference on Artificial Intelligence},Vol. 25.

\leavevmode\hypertarget{ref-sreedharan_handling_2018}{}%
Sreedharan, S., Chakraborti, T., and Kambhampati, S. (2018). Handling
Model Uncertainty and Multiplicity in Explanations via Model
Reconciliation. In \emph{International Conference on Automated Planning
and Scheduling}.

\leavevmode\hypertarget{ref-sreedharan_hierarchical_2018}{}%
Sreedharan, S., Srivastava, S., and Kambhampati, S. (2018). Hierarchical
Expertise-Level Modeling for User Specific Robot-Behavior Explanations.
In \emph{International Joint Conference on Artificial Intelligence}.

\leavevmode\hypertarget{ref-weld_introduction_1994}{}%
Weld, D. S. (1994). An introduction to least commitment planning.
\emph{AI Magazine}, \emph{15}(4), 27.

\leavevmode\hypertarget{ref-young_dpocl_1994}{}%
Young, R. M., and Moore, J. D. (1994). DPOCL: A principled approach to
discourse planning. In \emph{Proceedings of the Seventh International
Workshop on Natural Language Generation}, pages 13--20. Association for
Computational Linguistics.

\end{document}
